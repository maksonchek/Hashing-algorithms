# ГОСТ Р 34.11-94

# Функция замены S-блоков (заменяет каждый байт блока на соответствующее значение из S-блока)
def substitution(block, sbox):
    return [sbox[byte >> 4][byte & 0x0F] for byte in block]

# Функция перестановки (циклический сдвиг байт влево)
def permutation(block):
    return block[11:] + block[:11] + block[23:] + block[15:23]


# Хеширование сообщения
def gost_hash(message):
    sbox = [
        [0x1, 0x2, 0x3, 0x4, 0x5, 0x6, 0x7, 0x8, 0x9, 0xA, 0xB, 0xC, 0xD, 0xE, 0xF],
        [0x4, 0xA, 0x9, 0x2, 0xD, 0x8, 0x0, 0xE, 0x6, 0xB, 0x1, 0xC, 0x7, 0xF, 0x5, 0x3],
        [0xE, 0xB, 0x4, 0xC, 0x6, 0xD, 0xF, 0xA, 0x2, 0x3, 0x8, 0x1, 0x0, 0x7, 0x5, 0x9],
        [0x5, 0x8, 0x1, 0xD, 0xA, 0x3, 0x4, 0x2, 0xE, 0xF, 0xC, 0x7, 0x6, 0x0, 0x9, 0xB],
        [0x7, 0xD, 0xA, 0x1, 0x0, 0x8, 0x9, 0xF, 0xE, 0x4, 0x6, 0xC, 0xB, 0x2, 0x5, 0x3],
        [0x6, 0xC, 0x7, 0x1, 0x5, 0xF, 0xD, 0x8, 0x4, 0xA, 0x9, 0xE, 0x0, 0x3, 0xB, 0x2],
        [0x4, 0xB, 0xA, 0x0, 0x7, 0x2, 0x1, 0xD, 0x3, 0x6, 0x8, 0x5, 0x9, 0xC, 0xF, 0xE],
        [0xD, 0xB, 0x4, 0x1, 0x3, 0xF, 0x5, 0x9, 0x0, 0xA, 0xE, 0x7, 0x6, 0x8, 0x2, 0xC],
        [0x1, 0xF, 0xD, 0x0, 0x5, 0x7, 0xA, 0x4, 0x9, 0x2, 0x3, 0xE, 0x6, 0xB, 0x8, 0xC]
    ]

    block_size = 32  # Размер блока в байтах
    message_blocks = [message[i:i+block_size] for i in range(0, len(message), block_size)]
    iv = [0] * block_size  # Вектор инициализации

    for block in message_blocks:
        # Применение функции замены к блоку
        block = substitution(block, sbox)
        # Побитовая операция XOR между блоком и предыдущим блоком (или IV в случае первого блока)
        block = [x ^ y for x, y in zip(block, iv)]
        # Применение функции перестановки к результату
        block = permutation(block)
        # Обновление вектора инициализации
        iv = block

    return iv  # Возврат конечного значения хеша

# Шифрование данных
def gost_encrypt(message):
    sbox = [
        [0x1, 0x2, 0x3, 0x4, 0x5, 0x6, 0x7, 0x8, 0x9, 0xA, 0xB, 0xC, 0xD, 0xE, 0xF],
        [0xA, 0x4, 0x5, 0x6, 0x8, 0x1, 0x3, 0x7, 0xD, 0xC, 0xE, 0x0, 0x9, 0x2, 0xB, 0xF],
        [0x5, 0xF, 0x4, 0x0, 0x2, 0xD, 0xB, 0x9, 0x1, 0x7, 0x6, 0x3, 0xC, 0xE, 0xA, 0x8],
        [0x7, 0xF, 0xC, 0xE, 0x9, 0x4, 0x1, 0x0, 0x3, 0xB, 0x5, 0x2, 0x6, 0xA, 0x8, 0xD],
        [0x4, 0xA, 0x7, 0xC, 0x0, 0xF, 0x2, 0x8, 0xE, 0x1, 0x6, 0x5, 0xD, 0xB, 0x9, 0x3],
        [0x7, 0x6, 0x4, 0xB, 0x9, 0xC, 0x2, 0xA, 0x1, 0x8, 0x0, 0xE, 0xF, 0xD, 0x3, 0x5],
        [0x7, 0x6, 0x2, 0x4, 0xD, 0x9, 0xF, 0x0, 0xA, 0x1, 0x5, 0xB, 0x8, 0xE, 0xC, 0x3],
        [0xD, 0xE, 0x4, 0x1, 0x7, 0x0, 0x5, 0xA, 0x3, 0xC, 0x8, 0xF, 0x6, 0x2, 0x9, 0xB],
        [0x1, 0x3, 0xA, 0x9, 0x5, 0xB, 0x4, 0xF, 0x8, 0x6, 0x7, 0xE, 0xD, 0x0, 0x2, 0xC]
    ]

    block_size = 32  # Размер блока в байтах
    message_blocks = [message[i:i+block_size] for i in range(0, len(message), block_size)]
    iv = [0] * block_size  # Вектор инициализации

    encrypted_message = []

    for block in message_blocks:
        # Применение функции перестановки к блоку
        block = permutation(block)
        # Побитовая операция XOR между блоком и предыдущим блоком (или IV в случае первого блока)
        block = [x ^ y for x, y in zip(block, iv)]
        # Применение функции замены к результату
        block = substitution(block, sbox)
        # Обновление вектора инициализации
        iv = block
        # Добавление зашифрованного блока к зашифрованному сообщению
        encrypted_message.extend(block)

    return encrypted_message  # Возврат зашифрованного сообщения